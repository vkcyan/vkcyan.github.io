<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript深入之参数按值传递 · vkcyan</title><meta name="description" content="JavaScript深入之参数按值传递 - vkcyan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="vkcyan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/www.vkcyan.top" target="_self" class="nav-list-link">简历</a></li><li class="nav-list-item"><a href="https://github.com/vkcyan" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript深入之参数按值传递</h1><div class="post-info">Jul 15, 2018</div><div class="post-content"><p>在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数： </p>
<p>ECMAscript中所有函数的参数都是按值传递</p>
<h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><blockquote>
<p>也就是,把函数外部的值复制给函数内部的参数,就和把值从一个变量复制到另一个变量一样</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">    v = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(value);</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>当传递value给函数foo的时候,相当于拷贝一份value给foo假设拷贝的那份叫v,函数中修改的都是v,不会一项原来的value值</p>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>按值传递里面的拷贝虽然好理解 但是当值是一个复杂的数据结构的时候,拷贝就会产生性能问题</p>
<p>所以还有另外的传递方式叫做按<strong>引用传递</strong></p>
<p>所谓按引用传递,就是传递对象的引用,函数内部对参数的任何改变都会影响该对象的值,因为两者引用的是同一个对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">      value : <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> foo = <span class="function">(<span class="params">o</span>)=&gt;</span> &#123;</span><br><span class="line">      o.value = <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(o.value);</span><br><span class="line">    &#125;</span><br><span class="line">    foo(obj)</span><br><span class="line">    <span class="built_in">console</span>.log(obj.value);</span><br></pre></td></tr></table></figure>
<p>这里产生了一个疑问?</p>
<p>红宝书都说了 ECMAScript 中所有函数的参数都是按值传递的，这怎么能按”引用传递”成功呢？ </p>
<h3 id="我们看第三个例子"><a href="#我们看第三个例子" class="headerlink" title="我们看第三个例子"></a>我们看第三个例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(o); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如果 JavaScript 采用的是引用传递，外层的值也会被修改呐，这怎么又没被改呢？所以真的不是引用传递吗？ </p>
<p>这就要讲到其实还有第三种传递方式，叫按共享传递。</p>
<p>而共享传递是指，在传递对象的时候，传递对象的引用的副本。</p>
<p>关键点:</p>
<blockquote>
<p>运算符<code>=</code>就是<strong>创建或修改</strong>变量在内存中的指向.<br>初始化变量时为创建,重新赋值即为修改.</p>
</blockquote>
<p>为了解释上面的共享传递 这里在看一个例子摸清楚内存中的分布</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;;<span class="comment">// a = &#123;b: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> c = a;<span class="comment">// c = &#123;b: 1&#125;</span></span><br><span class="line">a = <span class="number">2</span>;<span class="comment">// 重新赋值a</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">// &#123;b: 1&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>创建变量a指向对象{b:1}</li>
<li>创建变量c指向对象{b:1}</li>
<li>a又重新指向常量2</li>
</ol>
<p>但是这时候c依旧指向对象{b:1}</p>
<p>这样我们回头看第一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v = value; <span class="comment">// 创建变量v指向value所指向的值</span></span><br><span class="line">    v = <span class="number">2</span>;<span class="comment">// v重新指向另外的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(value);</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 1,value从始至终都未改变指向.</span></span><br></pre></td></tr></table></figure>
<p>现在吧第一个例子修改成对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;;<span class="comment">// a = &#123;b: 1&#125;</span></span><br><span class="line"><span class="keyword">var</span> c = a;<span class="comment">// c = &#123;b: 1&#125;</span></span><br><span class="line">a.b = <span class="number">2</span>;<span class="comment">// 重新赋值对象a中的属性b</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>栈</th>
<th>堆</th>
<th>常量区</th>
</tr>
</thead>
<tbody>
<tr>
<td>a,c</td>
<td>[object]</td>
<td></td>
</tr>
<tr>
<td>b</td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>执行完<code>a.b = 2</code>后: </p>
<table>
<thead>
<tr>
<th>栈</th>
<th>堆</th>
<th>常量区</th>
</tr>
</thead>
<tbody>
<tr>
<td>a,c</td>
<td>[]object</td>
<td></td>
</tr>
<tr>
<td>b</td>
<td></td>
<td>2</td>
</tr>
</tbody>
</table>
<blockquote>
<p>a,c从始至终都没有改变指向,变的是b而已</p>
</blockquote>
<p>现在再看第二个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">   value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> o = obj;</span><br><span class="line">   o.value = <span class="number">2</span>;<span class="comment">// 变量value改变了指向,而o并未改变</span></span><br><span class="line">   <span class="built_in">console</span>.log(o.value); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>所以 js始终是按值传递,在这里称他为共享传递</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/26/解决8080端口占用问题/" class="prev">上一篇</a><a href="/2018/07/14/vue 路由钩子afterEach beforeEach/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 <a href="http://yoursite.com">vkcyan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>