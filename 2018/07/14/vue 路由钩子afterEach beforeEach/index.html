<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Vue路由钩子 afterEach beforeEach区别 · vkcyan</title><meta name="description" content="Vue路由钩子 afterEach beforeEach区别 - vkcyan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="vkcyan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li><li class="nav-list-item"><a href="https://github.com/vkcyan" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Vue路由钩子 afterEach beforeEach区别</h1><div class="post-info">Jul 14, 2018</div><div class="post-content"><p>使用vue已经有一段是时间了,这不断的写项目里面,基本上清楚了vue的这种与jq完成不一样的思想,越是研究越是感觉作者之强大,对vue SPA单页面里面最常用的vue-router组件,今天就谈谈这个,我使用的经验</p>
<p>​    vue-router作为vue里面最基础的服务,学习一段时间,对遇到的需求进行一些总结</p>
<p>使用vue-cli作为开发前提 vue-router已经配置好了</p>
<p>路由写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> routes: [</span><br><span class="line">   &#123;</span><br><span class="line">       path: &apos;/cart&apos;,</span><br><span class="line">       name: &apos;cart&apos;,</span><br><span class="line">       component: cart,</span><br><span class="line">       meta :&#123; title: &quot;购物车&quot;&#125;				//用于给定网页名</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="vue-router-的路由跳转的方法"><a href="#vue-router-的路由跳转的方法" class="headerlink" title="vue-router 的路由跳转的方法"></a>vue-router 的路由跳转的方法</h3><p>第一种 : 编程式的导航</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/&quot; tag=&quot;p&quot;&gt;耳机频道&lt;/router-link&gt;</span><br><span class="line">//to是一个prop.指定需要跳转的路径,也可以使用v-bind动态设置</span><br><span class="line">//tag可以指定渲染成标签,默认是a标签</span><br><span class="line">&lt;router-link to=&quot;/&quot; replace&gt;跳转回去&lt;/router-link&gt;   </span><br><span class="line">//这样的写法是不会留下历史痕迹,回退键无效</span><br><span class="line">&lt;router-link :to=&quot;&#123; name: &apos;product&apos;, params: &#123; id : 1 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;</span><br><span class="line">// /product/1</span><br></pre></td></tr></table></figure>
<p>第二种 : 函数式的导航</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这里假设 我要跳转product页面并且附带参数id  </span><br><span class="line">//这里定义好了list.id 就是 动态的值</span><br><span class="line">this.$router.push(&apos;./product/&apos; + list.id)						// 字符串的方式进行描述</span><br><span class="line">this.$router.push(&#123;name : &apos;product&apos;,params: &#123; id : list.id &#125;&#125;)	  // 命名的路由的方式进行描述</span><br><span class="line">this.$router.push(&#123; path: `/product/$&#123;list.id&#125;` &#125;)				 // 直接定义path类似第一种</span><br><span class="line">//比较常用的跳转路由的方法</span><br><span class="line">//假如是带查询参数</span><br><span class="line">router.push(&#123; path: &apos;product&apos;, query: &#123; id: list.id &#125;&#125;)            // /product?id=1</span><br></pre></td></tr></table></figure>
<p> 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。 </p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。 </p>
<p><strong>值得注意的一点是,如果提供了 path，params 的配置将不会生效</strong> </p>
<p>还有一些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.replace		//它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录</span><br><span class="line">router.go(1)	 	//在浏览器记录里面前进一步,等于history.forward()</span><br><span class="line">router.go(-1)		//后退一步记录，等同于 history.back()</span><br><span class="line">router.go(n)		//浏览器记录前进3步</span><br></pre></td></tr></table></figure>
<p>基本使用大概就这么多<br>还有 命名视图 路由重定向 等等需要的请看官网</p>
<p>基本知识大概就这么多 </p>
<h3 id="现在说说正题-afterEach-beforeEach这两个导航守卫的区别"><a href="#现在说说正题-afterEach-beforeEach这两个导航守卫的区别" class="headerlink" title="现在说说正题 afterEach beforeEach这两个导航守卫的区别"></a>现在说说正题 afterEach beforeEach这两个导航守卫的区别</h3><p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p>
<p>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。</p>
<p>在全局守卫里面</p>
<p>beforeEach 全局前置守卫 </p>
<p>当一个导航触发时，全局前置守卫按照创建顺序调用。 </p>
<p>每个守卫方法接收三个参数：</p>
<ul>
<li><strong>to: Route</strong>: 即将要进入的目标 <a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">路由对象</a></li>
<li><strong>from: Route</strong>: 当前导航正要离开的路由</li>
<li><strong>next: Function</strong>: 一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(to);    <span class="comment">//即将要进入的路由对象</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">from</span>);  <span class="comment">//当前导航要离开的路由对象</span></span><br><span class="line">  </span><br><span class="line">   next();             <span class="comment">//调用该方法,才能进入下一个钩子</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这样写就可以明显的看出每个参数的意义</span></span><br></pre></td></tr></table></figure>
<p><strong>next()</strong>: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <strong>confirmed</strong> (确认的)。 </p>
<p><strong>next(false)</strong>: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 <code>from</code> 路由对应的地址。 </p>
<p><strong>next(‘/‘) 或者 next({ path: ‘/‘ })</strong>: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://router.vuejs.org/zh/api/#to" target="_blank" rel="noopener"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://router.vuejs.org/zh/api/#router-push" target="_blank" rel="noopener"><code>router.push</code></a> 中的选项。 </p>
<p><strong>确保要调用 next 方法，否则钩子就不会被 resolved</strong> </p>
<p>afterEach 全局后置钩子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to, from) =&gt; &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身</p>
<p>从使用的角度来说 前置钩子更加常用,比如<strong>登录验证</strong> 以及给<strong>Vue单页面引用规定网页名</strong>等等,这些案例我的github里面有,如果想了解一下思路可以看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to,from,next) =&gt; &#123;</span><br><span class="line">  if(to.meta.title) &#123;</span><br><span class="line">    document.title = to.meta.title;    //在路由里面写入的meta里面的title字段</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">组件内的守卫</a>请看官网的例子</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/15/JavaScript深入 - 参数按值传递/" class="prev">上一篇</a><a href="/2018/05/14/cmder的一些问题/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 - 2020 <a href="http://yoursite.com">vkcyan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>