<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript - 异步的前世今生 · vkcyan</title><meta name="description" content="JavaScript - 异步的前世今生 - vkcyan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="vkcyan"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">简历</a></li><li class="nav-list-item"><a href="https://github.com/vkcyan" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript - 异步的前世今生</h1><div class="post-info">Aug 20, 2018</div><div class="post-content"><h1 id="JavaScript-异步的前世今生"><a href="#JavaScript-异步的前世今生" class="headerlink" title="JavaScript - 异步的前世今生"></a>JavaScript - 异步的前世今生</h1><p>​    在开始接触JavaScript的时候,书上有一句话我记忆深刻,<strong>JavaScript是一门单线程语言</strong>,不管从什么途径去获取这个消息,前端开发者都会记住,哦~~,JavaScript是一门单线程语言,所以alert()会卡住</p>
<p>​     <strong>为什么JavaScript是一门单线程语言?因为什么原因让JavaScript出生就是单线程语言?</strong></p>
<p>​    提出问题,必然解决问题,从JavaScript出生说起,最开始JavaScript是配合html去完成对dom的控制,优化用户交互,于是问题来了</p>
<ul>
<li>js可以修改Dom结构</li>
<li>浏览器渲染Dom结构</li>
</ul>
<p>假如同时执行,会发生什么,假如同时操作同一个Dom怎么办,</p>
<p>同理 两段js都修改Dom结构,假如同时操作Dom会发生什么</p>
<p>js没有执行的时候,浏览器Dom渲染,js执行的时候,浏览器Dom停止渲染,html结构树本来是就是从上往下渲染,也就是说,浏览器渲染Dom本身就是单线程,js为了避免发生Dom冲突,没有办法只能成为单线程语言</p>
<p>但是单线程的硬伤出现了,单线程意味着页面加载会卡顿,线程被占用浏览器卡死</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;  <span class="comment">//单线程占用</span></span><br><span class="line">    sum++</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line">alert(<span class="string">"100"</span>)   <span class="comment">//单线程占用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我终于执行啦"</span>);</span><br></pre></td></tr></table></figure>
<p>​    例如上面的代码,浏览器资源类占用,就会发生可怕的事情,浏览器卡死,也许这里for循环不形式,但是现实开发里面同步ajax请求慢的时候页面卡死是正常事</p>
<h3 id="同步解决方案-异步"><a href="#同步解决方案-异步" class="headerlink" title="同步解决方案 - 异步"></a>同步解决方案 - 异步</h3><p>说到异步,不得不谈大名鼎鼎的event-loop(事件轮询)</p>
<p>相信开发者一定看过<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">阮一峰大神对Event loop的解释</a>,除了图有点看不懂之外,其他都讲的很请求</p>
<p>这里要说一道比较老的面试题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"我是定制器"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"我是主进程"</span>);</span><br></pre></td></tr></table></figure>
<p>很简单 先执行<code>console.log(&quot;我是主进程&quot;);</code> ,为什么呢?即使因为事件轮询</p>
<p>当浏览器从上往下解析,遇到setTimeout,setTimeout是异步任务,浏览器就会将他放入异步任务里面,然后执行主线程的代码,当主线程的代码执行完毕,事件轮询就是去查看异步任务,于是执行了setTimeout里面的函数</p>
<p>这就是事件轮询</p>
<p>这里借阅阮一峰大神的一段博客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</span><br><span class="line"></span><br><span class="line">如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</span><br><span class="line"></span><br><span class="line">JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。</span><br><span class="line"></span><br><span class="line">于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span><br><span class="line"></span><br><span class="line">具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）</span><br><span class="line"></span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line"></span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line"></span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line"></span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure>
<p>​    event-loop就像哨兵一样,监视着异步队列,一旦有异步代码,就会在主线程执行完毕将异步方法,读取到主线程,在回去监视异步队列,所以event-loop也叫事件轮询</p>
<h3 id="jQuery-deferred"><a href="#jQuery-deferred" class="headerlink" title="jQuery.deferred()"></a>jQuery.deferred()</h3><p>无法改变 JS 异步和单线程的本质 </p>
<p>只能从写法上杜绝 callback 这种形式 </p>
<p>他是语法糖,但是解构了代码</p>
<p>体现了编程思想 : 开放封闭原则</p>
<blockquote>
<p>对拓展开放,对修改封闭,      越是深入模块化,越是体现这样的实现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　$.ajax(&#123;</span><br><span class="line">　　　　url: <span class="string">"test.html"</span>,</span><br><span class="line">　　　　success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(<span class="string">"哈哈，成功了！"</span>);</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(<span class="string">"出错啦！"</span>);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;);</span><br></pre></td></tr></table></figure>
<p>老版本的使用的是回调函数形式,那么假如我们想修改代码,势必要对$.ajax({})里面的所有代码进行变成 这就成了</p>
<p>对拓展封闭,对修改封闭,这是对在开发上非常不友好的变成方式,牵一发而动全身</p>
<p>当deferred出现后,ajax变成了链式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　$.ajax(<span class="string">"test.html"</span>)</span><br><span class="line"></span><br><span class="line">　　.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"哈哈，成功了！"</span>); &#125;)</span><br><span class="line"></span><br><span class="line">　　.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"出错啦！"</span>); &#125;);</span><br></pre></td></tr></table></figure>
<p>这里明显可以看到对修改封闭,对拓展开放</p>
<p>假如我们想拓展</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"第二个回调函数！"</span>);&#125; );</span><br></pre></td></tr></table></figure>
<p>完全不影响之前的代码,代码耦合性低</p>
<p>在我最开始接触jquery的时候,ajax有三种写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//成功回调</span></span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//失败回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;url&#125;)</span><br><span class="line">.done(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//成功回调</span></span><br><span class="line">&#125;)</span><br><span class="line">.fail((<span class="number">0</span>=&gt; &#123;</span><br><span class="line">    <span class="comment">//失败回调</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;url&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//成功回调</span></span><br><span class="line">&#125;,</span><br><span class="line">()=&gt; &#123;</span><br><span class="line">    <span class="comment">//失败回调</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>刚开始不解,为什么第一种是淘汰的写法.再后来渐渐深入才发现回调的局限性,</p>
<ul>
<li>耦合性太高,</li>
<li>不支持链式调用,</li>
<li>不利于维护,回调里代码过于复杂会产生风险</li>
</ul>
<p>这让我想探究一下,如何实现.done.fail,所以就不得不说jQuery的deferred</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="noopener">阮一峰大神对deferred的讲解</a></p>
<p>在使用jq我们可以使用deferred帮助我们控制异步</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waitHandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> dtd = $.Deferred()</span><br><span class="line">      <span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params">dtd</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"执行完成"</span>);</span><br><span class="line">          dtd.resolve()</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(task, <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> dtd.promise()  <span class="comment">//返回pomise对象 防止在回调里面执行控制回调的函数 例如reject()</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wait(dtd) <span class="comment">//返回wait的执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    waitHandle()</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">      &#125;, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hahah"</span>);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      &#125;, () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hahah"</span>);</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>
<p>这里我就不赘述了,前人已经全面的总结了;这里明显看到,这是已经初步提出了promise的概念,对日后的标准建立的基础</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>对于低版本浏览器,想要使用第三方库,可以使用<a href="https://cdn.bootcss.com/bluebird/3.5.1/bluebird.min.js" target="_blank" rel="noopener">bluebird.js</a>,对promise进行实现</p>
<p>老生长谈了,开发必须要会</p>
<blockquote>
<p>这是jq的deferred的进阶版啊,,开发者卸磨杀驴,竟然说jq淘汰了,一叶障目</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">     img.onload = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">       resolve(img)</span><br><span class="line">     &#125;</span><br><span class="line">     img.onerror = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">       reject(<span class="string">"图片加载失败"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     img.src = src</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> load1 = loadImg(<span class="string">"https://secure.gravatar.com/avatar/7337a05ac8210b3f1b522818cd31b90d?s=86"</span>)</span><br><span class="line"><span class="keyword">var</span> load2 = loadImg(<span class="string">"https://avatars2.githubusercontent.com/u/33681955?s=460&amp;v=4"</span>)</span><br><span class="line">load1.then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.width);</span><br><span class="line">  <span class="keyword">return</span> load2   <span class="comment">//后面的是load2的回调  对于请求串联 可以这么写 </span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.width);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise.all </p>
<blockquote>
<p>接受一个Promise对象的数组,待全部完成后,统一执行then,失败一个catch</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([load1,load2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch (<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">//假如有一个失败就会返回catch</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>Pormise.race</p>
<blockquote>
<p>接收一个包含多个Promise对象的数组,主要完成一个就执行then,失败一个catch</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([load1, load2])</span><br><span class="line">	.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(res); <span class="comment">//成功一个立马返回</span></span><br><span class="line">	&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(res); <span class="comment">//假如有一个失败就会返回catch</span></span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="在Peomise上还要说一点就是状态变化"><a href="#在Peomise上还要说一点就是状态变化" class="headerlink" title="在Peomise上还要说一点就是状态变化"></a>在Peomise上还要说一点就是状态变化</h4><p>三种状态: pending(待定的) fulfilled(满足的) rejected(拒绝) </p>
<p>规则: <strong>状态变化不可逆</strong></p>
<p>在初始状态下,Promise是pending 只有两种情况</p>
<ul>
<li>Promise执行成功 pending 成功状态变成fulfilled</li>
<li>Promise执行成功 pending 失败状态变成rejected</li>
</ul>
<p>了解一下</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>then是将callback进行拆分了</p>
<p>关于async/await 其实网上资料也挺多的,将异步代码同步进行,取消了.then这样的写法,回归本源</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result1 = <span class="keyword">await</span> loadImg(load1)</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">let</span> result2 = <span class="keyword">await</span> loadImg(load2)</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结一下JavaScript异步的前世今生"><a href="#总结一下JavaScript异步的前世今生" class="headerlink" title="总结一下JavaScript异步的前世今生"></a>总结一下JavaScript异步的前世今生</h5><ul>
<li>JavaScript是单线程,两段js不可以同时进行</li>
<li>原因是为了避免 DOM的渲染冲突</li>
<li>异步就是”无奈的解决方案”,但是初期有很多问题</li>
<li>异步是event loop实现的,事件轮询 异步方法 进入的异步队列,主线程执行完毕才会去执行异步队列里面的代码</li>
<li>jQuery Deferred,改变了异步只能由callback操作这个问题</li>
<li>deferred和Promise 有区别的 Promise对deferred进行优化 ,让Promise对象只能被动监听结果,避免冲突</li>
<li>Promise的出现成为了对异步的最佳解决方案相对于callback,极大的降低了耦合性</li>
<li>async/await 配合Promise 成为终极解决方案,但是ES7为成为正式版,未来仍需参考</li>
</ul>
<h3 id="异步的解决方案"><a href="#异步的解决方案" class="headerlink" title="异步的解决方案"></a>异步的解决方案</h3><ul>
<li>回调函数 - callback</li>
<li>初代链式 -  deferred (我觉得这个有必要提出来,改变js异步编程的关键)</li>
<li>成熟方案 - promise</li>
<li>终极方案 - async/await + promise</li>
<li>迭代器  Generator(同样实现异步,但是被async/await替代) </li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/08/28/vue-MYCLI/" class="prev">上一篇</a><a href="/2018/08/20/cookie sessionStorage localStorage的区别/" class="next">下一篇</a></div><div class="copyright"><p>© 2018 <a href="http://yoursite.com">vkcyan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>